# Battle for Indent [![Build Status](https://travis-ci.com/ficrus/battle-for-indent.svg?branch=dev)](https://travis-ci.com/ficrus/battle-for-indent)

## Об игре

**Battle for Indent** - это небольшая стратегия, в которой Вам предстоит защитить свой замок от нападения заклятого врага.
В Вашем распоряжении находятся лучшие войны Отступляндии, которые ценой своей жизни готовы отстаивать идеалы своего военачальника.


## Завязка

Война... война не меняется. Люди всегда находят повод поднять друг против друга мечи.
Так произошло и в этой истории. Некогда неразлучимые правители в один день узнали друг о друге страшную тайну.
Как оказалось, один из них в своих письмах делает отступы с помощью табуляции, а второй - с помощью пробелов.
Никакое чудо не смогло бы сохранить их дружеские узы после такого предательства.
Отныне они самые настоящие враги, которые не успокоятся, пока их принципы не скажут последнее слово.

## Описание игрового процесса

Игровая карта представляет из себя два замка, стоящих слева и справа, а также N (вероятнее всего, 3) троп, соединяющих их.

У каждого игрока (игроком слева может выступать только человек, а игроком справа может быть как человек, так и ИИ) в распоряжении имеется N (вероятнее всего, 5) юнитов, доступных для отправки на поле боя.
Данные юниты имеют свои характеристики и отличительные особенности, что делает важным выбор своего войска (к примеру, будет нетривиальной задачей победить одними волшебниками противника, у которого есть юнит, устойчивый к любым магическим атакам).

Помимо выбора войска, важную особенность будет играть путь, по которому будет отправлен этот юнит. Каждая из троп имеет свои особенности, поэтому в разных ситуациях эти особенности могут стать как и тузом в рукаве, так и медвежьей услугой.

Как только юнит доберется до вражеского замка, начнётся его осада. По завершении осады победа присуждается осаждавшему игроку.

__На данный момент взаимодействие юнитов друг с другом и картой не реализовано, поскольку одних порождающих паттернов для качественного решения данной задачи недостаточно.__


## Юниты

Общее определение того, что из себя представляют юниты, излишне.
Рассмотрим техническую сторону реализации юнитов в данной игре.
Каждый класс юнита наследуется от абстрактного класса `BaseUnit`, имеющего следующие поля:

1. `fraction`
2. `job`
3. `hp`
4. `physical_damage`
5. `magical_damage`
6. `physical_resist`
7. `magcal_resist`
8. `move_speed`
9. `attack_speed`

Первое из них определяет сторону, за которую воюет данный юнит. Второе - его класс. Название остальных полей говорит само за себя.
Расширение списка юнитов не составляет никакого труда, поскольку все функции и методы, отвечающие за работу с юнитами, принимают в качестве аргумента `BaseUnit`. То есть `Bandit`, `Knight`, `Mage`, `Developer` и тому подобные юниты будут иметь общий интерфейс.

Для создания юнитов используются фабрики (паттерн `Factory Method`). Каждая из фабрик наследуется от абстрактного класса `UnitFactory`, имеющего абстрактный метод `create`.
Как и в случае с юнитами, работа с фабриками происходит через один интерфейс.
Достоинством данного паттерна в данной ситуации является то, что мы не работаем с каждым классом юнита напрямую, мы используем при создании общий для них всех интерфейс. 

![UML диаграмма](/img/gamediag1.png)

На UML диаграмме выше показаны отношения между описанными классами.

Также в работу фабрик был внедрён паттерн `Singleton`. В нашей ситуации паттерн гарантирует, что во время работы программы будет создано не более одной фабрики для каждого класса юнитов.
Это гарантирует, что все юниты, имеющие одинаковое значение поля `job` будут созданы одинаково.

**Отметим, что на данный момент в игре присутствует только два юнита. Это не связано с тем, что добавлять юниты тяжело. Напротив, выше описано, почему это происходит без каких-либо осложнений.
Было решено оставить всего два юнита для демонстрации, поскольку в дальнейшем может потребоваться небольшая доработка абстрактного класса `BaseUnit` (например, при введении в работу поведенческих паттернов).**

## Армии

Для того, чтобы разделять юнитов, принадлежащих разным сторонам, был создан класс `Army`. Данный класс имеет метод `add_unit`, добавляющий юнита в текущую армию. Ещё раз отметим, что на вход он принимает `BaseUnit`, поэтому неважно, какой именно юнит мы будем добавлять.

## Сетевая игра

На данный момент не начата разработка данной части геймплея.

Так как игровой процесс для обеих сторон симметричен, то сетевая игра возможна, причём для обоих игроков она будет выглядеть одинаково.

## Зависимости

Для корректного запуска программы необходимо иметь установленными все пакеты из файла `requirements.txt`.
Установить пакеты можно с помощью инструмента `pip`. 

## Тестирование

Если требуется протестировать работоспособность компонентов игры, можно вопспользоваться инструментом `pytest`.
При запуске она запустит все тесты из папки `tests`.
Успешное прохождение всех тестов будет означать то, что все модули программы функционируют нормально.

## Демонстрация

Для реализации графического интерфейса игры был выбран модуль `arcade`.

Файл `example.py` представляет собой демонстрацию создания юнитов разных классов и их компонование в две разные армии.

Перед запуском данного файла прочтите пункт "Зависимости" этого краткого руководства по игре.
